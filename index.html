<script>
 // --- 1. Three.js 场景初始化 ---
 const scene = new THREE.Scene();
 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
 camera.position.z = 30;

 const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
 renderer.setSize(window.innerWidth, window.innerHeight);
 document.getElementById('canvas-container').appendChild(renderer.domElement);

 // --- 2. 创建爱心粒子系统 ---
 const particleCount = 3000;
 const geometry = new THREE.BufferGeometry();
 const positions = new Float32Array(particleCount * 3);
 const targetPositions = new Float32Array(particleCount * 3);
 const randomPositions = new Float32Array(particleCount * 3);

 // 爱心方程函数（移到粒子系统初始化前）
 function getHeartPosition(t, scale = 1) {
     const x = 16 * Math.pow(Math.sin(t), 3);
     const y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
     const z = 0; 
     return { x: x * scale, y: y * scale, z: z * scale };
 }

 // 填充粒子位置（原代码这部分保留）
 for (let i = 0; i < particleCount; i++) {
     // ...原代码的粒子位置初始化逻辑
 }
 geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

 // 粒子材质（原代码保留）
 const material = new THREE.PointsMaterial({
     color: 0xff69b4,
     size: 0.4,
     transparent: true,
     opacity: 0.8,
     blending: THREE.AdditiveBlending
 });
 const particles = new THREE.Points(geometry, material);
 scene.add(particles);

 // --- 3. 交互逻辑变量 ---
 let gatherFactor = 0;
 let targetGatherFactor = 0;

 // --- 4. 鼠标点击爱心爆炸特效（移到animate外面）---
 function createClickHeart(x, y) {
   const clickGeometry = new THREE.BufferGeometry();
   const clickPositions = new Float32Array(30 * 3);
   const clickMaterial = new THREE.PointsMaterial({
     color: 0xff69b4,
     size: 0.5,
     transparent: true,
     opacity: 0.8
   });

   for (let i = 0; i < 30; i++) {
     const t = Math.random() * Math.PI * 2;
     const r = Math.sqrt(Math.random()) * 2;
     const heartX = 16 * Math.pow(Math.sin(t), 3) * r;
     const heartY = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) * r;
     clickPositions[i * 3] = x + heartX;
     clickPositions[i * 3 + 1] = y + heartY;
     clickPositions[i * 3 + 2] = (Math.random() - 0.5) * 2;
   }

   clickGeometry.setAttribute('position', new THREE.BufferAttribute(clickPositions, 3));
   const clickParticles = new THREE.Points(clickGeometry, clickMaterial);
   scene.add(clickParticles);

   let opacity = 0.8;
   function fadeOut() {
     opacity -= 0.02;
     clickParticles.material.opacity = opacity;
     clickParticles.rotation.y += 0.05;
     if (opacity > 0) {
       requestAnimationFrame(fadeOut);
     } else {
       scene.remove(clickParticles);
     }
   }
   fadeOut();
 }

 // 鼠标点击事件监听（只绑定一次，移到外面）
 renderer.domElement.addEventListener('click', (e) => {
   const mouse = new THREE.Vector2(
     (e.clientX / window.innerWidth) * 2 - 1,
     -(e.clientY / window.innerHeight) * 2 + 1
   );
   const raycaster = new THREE.Raycaster();
   raycaster.setFromCamera(mouse, camera);
   const intersects = raycaster.intersectObjects([particles]);
   if (intersects.length > 0) {
     const pos = intersects[0].point;
     createClickHeart(pos.x, pos.y);
   }
 });

 // --- 5. 鼠标跟随粒子特效（移到animate外面，且先定义函数再调用）---
const mouseParticles = [];
const mouseGeometry = new THREE.BufferGeometry();
const mousePositions = new Float32Array(50 * 3);
const mouseMaterial = new THREE.PointsMaterial({
  color: 0xffc0cb,
  size: 0.3,
  transparent: true,
  opacity: 0.9
});

for (let i = 0; i < 50; i++) {
  mousePositions[i * 3] = 0;
  mousePositions[i * 3 + 1] = 0;
  mousePositions[i * 3 + 2] = 0;
  mouseParticles.push({ x: 0, y: 0, z: 0, vx: 0, vy: 0 });
}

mouseGeometry.setAttribute('position', new THREE.BufferAttribute(mousePositions, 3));
const mouseParticleSystem = new THREE.Points(mouseGeometry, mouseMaterial);
scene.add(mouseParticleSystem);

let mouse = { x: 0, y: 0 };
window.addEventListener('mousemove', (e) => {
  mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
  const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
  vector.unproject(camera);
  const dir = vector.sub(camera.position).normalize();
  const distance = -camera.position.z / dir.z;
  const pos = camera.position.clone().add(dir.multiplyScalar(distance));
  mouse.x = pos.x;
  mouse.y = pos.y;
});

// 先定义updateMouseParticles，再在animate里调用
function updateMouseParticles() {
  const posAttr = mouseParticleSystem.geometry.attributes.position;
  const array = posAttr.array;

  mouseParticles.forEach((p, i) => {
    p.vx += (mouse.x - p.x) * 0.03;
    p.vy += (mouse.y - p.y) * 0.03;
    p.vx *= 0.9;
    p.vy *= 0.9;
    p.x += p.vx;
    p.y += p.vy;
    array[i * 3] = p.x;
    array[i * 3 + 1] = p.y;
    array[i * 3 + 2] = p.z + Math.sin(Date.now() * 0.001 + i) * 0.1;
  });

  posAttr.needsUpdate = true;
}

 // --- 6. MediaPipe Hands 配置（保留原逻辑，确认Camera使用）---
 const videoElement = document.getElementsByClassName('input_video')[0];

 function onResults(results) {
     document.getElementById('loading').style.display = 'none';

     if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
         const landmarks = results.multiHandLandmarks[0];
         const wrist = landmarks[0];
         const fingerTips = [4, 8, 12, 16, 20];
         let totalDist = 0;

         fingerTips.forEach(idx => {
             const tip = landmarks[idx];
             const dist = Math.sqrt(
                 Math.pow(tip.x - wrist.x, 2) + 
                 Math.pow(tip.y - wrist.y, 2)
             );
             totalDist += dist;
         });

         const avgDist = totalDist / 5;
         const closeThreshold = 0.25; 
         const openThreshold = 0.5;

         let normalized = (avgDist - closeThreshold) / (openThreshold - closeThreshold);
         normalized = 1 - Math.min(Math.max(normalized, 0), 1);
         targetGatherFactor = normalized; 

     } else {
         targetGatherFactor = 0;
     }
 }

 const hands = new Hands({locateFile: (file) => {
     return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
 }});

 hands.setOptions({
     maxNumHands: 1,
     modelComplexity: 1,
     minDetectionConfidence: 0.5,
     minTrackingConfidence: 0.5
 });

 hands.onResults(onResults);

 const cameraUtils = new Camera(videoElement, {
     onFrame: async () => {
         await hands.send({image: videoElement});
     },
     width: 640,
     height: 480
 });
 cameraUtils.start();

 // --- 7. 动画循环（只保留动画逻辑，不再嵌套函数/事件）---
 function animate() {
     requestAnimationFrame(animate);

     // 粒子旋转
     particles.rotation.y += 0.002;

     // 平滑聚合系数
     gatherFactor += (targetGatherFactor - gatherFactor) * 0.05;

     // 更新爱心粒子位置
     const posAttr = particles.geometry.attributes.position;
     const currentPositions = posAttr.array;

     for (let i = 0; i < particleCount; i++) {
         const idx = i * 3;
         const tx = randomPositions[idx] + (targetPositions[idx] - randomPositions[idx]) * gatherFactor;
         const ty = randomPositions[idx+1] + (targetPositions[idx+1] - randomPositions[idx+1]) * gatherFactor;
         const tz = randomPositions[idx+2] + (targetPositions[idx+2] - randomPositions[idx+2]) * gatherFactor;

         currentPositions[idx] += (tx - currentPositions[idx]) * 0.1;
         currentPositions[idx+1] += (ty - currentPositions[idx+1]) * 0.1;
         currentPositions[idx+2] += (tz - currentPositions[idx+2]) * 0.1;
     }
     posAttr.needsUpdate = true;

     // 更新鼠标跟随粒子
     updateMouseParticles();

     // 渲染场景
     renderer.render(scene, camera);
 }

 // 启动动画
 animate();

 // --- 8. 窗口适配（保留原逻辑）---
 window.addEventListener('resize', () => {
     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();
     renderer.setSize(window.innerWidth, window.innerHeight);
 });
</script>
